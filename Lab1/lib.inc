section .text
 
 
; Принимает код возврата и завершает текущий процесс
exit: 
    xor rax, rax,
    ret 

; Принимает указатель на нуль-терминированную строку, возвращает её длину
string_length:
    xor rax, rax 
    .loop:
      cmp  byte[rdi + rax], 0 
      je   .exit 
      inc  rax 
      jmp  .loop
    .exit:
    ret

; Принимает указатель на нуль-терминированную строку, выводит её в stdout
print_string:
    call string_length			
	   mov rsi, rdi				
	   mov rdx, rax				
	   mov rax, 1					
	   mov rdi, 1					
	   syscall
	   xor rax, rax
    ret

; Принимает код символа и выводит его в stdout
print_char:
    push rdi 
    mov rsi, rsp ; адрес вершины стэка
    mov rdi, 1 ; куда выводить (stdout)
    mov rdx, 1 ; сколько выводить
    mov rax, 1 ; код sys_write
    syscall
    pop rdi ; забираем символ со стэка
    ret

; Переводит строку (выводит символ с кодом 0xA)
print_newline:
    mov rax, 1					
   	mov rdi, 1					
	   mov rsi, 10		
	   mov rdx, 1			
	   syscall
 xor rax, rax	
 ret 

; Выводит беззнаковое 8-байтовое число в десятичном формате 
; Совет: выделите место в стеке и храните там результаты деления
; Не забудьте перевести цифры в их ASCII коды.
print_uint:
; rsp - голова стека, rdi - переданное число
    push r12
    push r13
    mov r12, rsp ; сохраним вершину стека в r12
    mov r13, 10 ; сохраним основание системы счисления для деления
    mov rax, rdi ; сохраним переданное чило в rax
    dec rsp
    mov byte[rsp], 0 ; dec+mov - "руками" делаем однобайтовый pop
	   .loop:
        dec rsp ; двигаем указатель
        xor rdx, rdx ; обнуляем rdx
        div  r13 ; делим на 10, остаток в rdx
        add rdx, 0x30 ; переводим в ASCII
        mov  byte[rsp], dl ; сохраняем в стeк
        test rax, rax ; установит ZF = 0, если rax = 0
        jz .print ; если ZF - 0, заканчиваем
        jmp .loop
	   .print:
    mov rdi, rsp ; аргумент для print_string
    call print_string ; выводим число в stdout
    mov rsp, r12						
 pop r13
 pop r12 ; восстановим регистры
 ret

; Выводит знаковое 8-байтовое число в десятичном формате 
print_int:
     xor rax, rax
													; rdi - переданное число
         mov rax, rdi ; сохраняем в rax
         test rax, rax ; установим флаги
         jns .not_minus ; если отрицательное, то пицем знак '-'
         mov  rdi, '-' ; помещаем минус для print_char
         push rax
         call print_char ; выводим минус
         pop rax
         neg rax ; приводим к положительному
         mov rdi, rax
         .not_minus:
         call print_uint ; выводим число 
         ret

; Принимает два указателя на нуль-терминированные строки, возвращает 1 если они равны, 0 иначе
string_equals:
    xor rax, rax
    ret

; Читает один символ из stdin и возвращает его. Возвращает 0 если достигнут конец потока
read_char:
    xor rax, rax
    ret 

; Принимает: адрес начала буфера, размер буфера
; Читает в буфер слово из stdin, пропуская пробельные символы в начале, .
; Пробельные символы это пробел 0x20, табуляция 0x9 и перевод строки 0x10.
; Останавливается и возвращает 0 если слово слишком большое для буфера
; При успехе возвращает адрес буфера. 
; Эта функция должна дописывать к слову нуль-терминатор

read_word:
    ret
 

; Принимает указатель на строку, пытается
; прочитать из её начала беззнаковое число.
; Возвращает в rax: число, rdx : его длину в символах
; rdx = 0 если число прочитать не удалось
parse_uint:
    xor rax, rax
    ret




; Принимает указатель на строку, пытается
; прочитать из её начала знаковое число.
; Если есть знак, пробелы между ним и числом не разрешены.
; Возвращает в rax: число, rdx : его длину в символах (включая знак, если он был) 
; rdx = 0 если число прочитать не удалось
parse_int:
    xor rax, rax
    ret 

; Принимает указатель на строку, указатель на буфер и длину буфера
; Копирует строку в буфер
; Возвращает длину строки если она умещается в буфер, иначе 0
string_copy:
    xor rax, rax
    ret
